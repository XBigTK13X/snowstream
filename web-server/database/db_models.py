import sqlalchemy as sa
import sqlalchemy.orm as orm
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import DateTime, Column, Integer
from sqlalchemy.sql import func
from typing import List

# Reminder -> back_populates is necessary to avoid a bunch of warnings and subtle bugs
BaseModel = declarative_base()
BaseModel.id = Column(Integer, primary_key=True, index=True)
BaseModel.created_at = Column(DateTime, default=func.now())
BaseModel.updated_at = Column(DateTime, default=func.now(), onupdate=func.now())

def set_primary_images(model):
    model.screencap_image = None
    model.poster_image = None
    screencap_is_meta = False
    poster_is_meta = False
    if not model.image_files:
        return model
    for image_file in model.image_files:
        if not model.poster_image or poster_is_meta:
            if 'poster' in image_file.kind:
                model.poster_image = image_file
                poster_is_meta = '/metadata/' in image_file.local_path
        if not model.screencap_image or screencap_is_meta:
            if 'screencap' in image_file.kind:
                model.screencap_image = image_file
                screencap_is_meta = '/metadata/' in image_file.local_path
    return model

class Stub:
    def __init__(self):
        pass

class User(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'snowstream_user'
    __tablename__ = "snowstream_user"
    username = sa.Column(sa.Text, nullable=False)
    display_name = sa.Column(sa.Text, nullable=True)
    hashed_password = sa.Column(sa.Text, nullable=True)
    enabled = sa.Column(sa.Boolean)
    permissions = sa.Column(sa.Text)
    has_password = sa.Column(sa.Boolean, nullable=False)
    access_tags: orm.Mapped[List["Tag"]] = orm.relationship(secondary="user_tag")
    access_shelves: orm.Mapped[List["Shelf"]] = orm.relationship(secondary="user_shelf")
    access_stream_sources: orm.Mapped[List["StreamSource"]] = orm.relationship(secondary="user_stream_source")

    def is_admin(self):
        return 'admin' in self.permissions

# This is a ticket for admission
# It tells snowstream
# - who the user is
# - what device the user is on
# - who counts for having watched content
# - what content the user is allowed to view
# This is only generated by the app server, and never stored in the DB
class Ticket:
    def __init__(self,ignore_watch_group:bool=False):
        self.client = None
        self.cduid = None
        self.watch_group = None
        if ignore_watch_group:
            self.watch_group = [-1]
        self.tag_ids = None
        self.shelf_ids = None
        self.stream_source_ids = None

    def tag_csv(self):
        return ','.join([f'{xx}' for xx in self.tag_ids])

    def has_shelf_restrictions(self):
        return self.shelf_ids != None

    def has_tag_restrictions(self):
        return self.tag_ids != None

    def has_stream_source_restrictions(self):
        return self.stream_source_ids != None

    def is_allowed(self,
        stream_source_id:int=None,
        tag_id:int=None,
        shelf_id:int=None,
        tag_ids:list[int]=None,
        tag_provider=None
    ):
        if stream_source_id != None:
            if self.stream_source_ids == None:
                return True
            return stream_source_id in self.stream_source_ids
        if tag_id != None:
            if self.tag_ids == None:
                return True
            return tag_id in self.tag_ids
        if shelf_id != None:
            if self.shelf_ids == None:
                return True
            return shelf_id in self.shelf_ids
        if tag_ids != None:
            if self.tag_ids == None:
                return True
            if not tag_ids:
                return False
            for allowed_tag_id in self.tag_ids:
                if allowed_tag_id in tag_ids:
                    return True
            return False
        if tag_provider != None:
            if self.tag_ids == None:
                return True
            tag_ids = tag_provider()
            if not tag_ids:
                return False
            for allowed_tag_id in self.tag_ids:
                if allowed_tag_id in tag_ids:
                    return True
            return False
        return True

class UserTag(BaseModel):
    __tablename__ = "user_tag"
    user_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("snowstream_user.id"))
    tag_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("tag.id"))

class UserShelf(BaseModel):
    __tablename__ = "user_shelf"
    user_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("snowstream_user.id"))
    shelf_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("shelf.id"))

class UserStreamSource(BaseModel):
    __tablename__ = "user_stream_source"
    user_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("snowstream_user.id"))
    stream_source_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("stream_source.id"))

class ClientDevice(BaseModel):
    __tablename__ = "client_device"
    reported_name = sa.Column(sa.Text)
    display_name = sa.Column(sa.Text)
    device_kind = sa.Column(sa.Text)

class ClientDeviceUser(BaseModel):
    __tablename__ = "client_device_user"
    user_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("snowstream_user.id"),nullable=False)
    client_device_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("client_device.id"),nullable=False)
    client_device: orm.Mapped['ClientDevice'] = orm.relationship()
    isolation_mode = sa.Column(sa.Text)
    last_connection = sa.Column(sa.DateTime)

class WatchProgress(BaseModel):
    __tablename__ = 'watch_progress'
    client_device_user_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("client_device_user.id"),nullable=False
    )
    client_device_user: orm.Mapped["ClientDeviceUser"] = orm.relationship()
    show_episode_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("show_episode.id"),nullable=True
    )
    show_episode: orm.Mapped['ShowEpisode'] = orm.relationship()
    movie_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("movie.id"),nullable=True
    )
    movie: orm.Mapped['Movie'] = orm.relationship()
    streamable_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("streamable.id"),nullable=True
    )
    streamable: orm.Mapped['Streamable'] = orm.relationship()
    played_seconds = sa.Column(sa.Float)
    duration_seconds = sa.Column(sa.Float)

class WatchCount(BaseModel):
    __tablename__ = 'watch_count'
    client_device_user_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("client_device_user.id"),nullable=False
    )
    client_device_user: orm.Mapped["ClientDeviceUser"] = orm.relationship()
    show_episode_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("show_episode.id"),nullable=True
    )
    show_episode: orm.Mapped['ShowEpisode'] = orm.relationship()
    movie_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("movie.id"),nullable=True
    )
    movie: orm.Mapped['Movie'] = orm.relationship()
    streamable_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("streamable.id"),nullable=True
    )
    streamable: orm.Mapped['Streamable'] = orm.relationship()
    amount = sa.Column(sa.Integer)

class Watched(BaseModel):
    __tablename__ = 'watched'
    client_device_user_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("client_device_user.id"),nullable=False
    )
    client_device_user: orm.Mapped["ClientDeviceUser"] = orm.relationship()
    movie: orm.Mapped['Movie'] = orm.relationship()
    movie_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("movie.id"),nullable=True
    )
    show_episode: orm.Mapped['ShowEpisode'] = orm.relationship()
    show_episode_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("show_episode.id"),nullable=True
    )
    streamable: orm.Mapped['Streamable'] = orm.relationship()
    streamable_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("streamable.id"),nullable=True
    )

class TranscodeSession(BaseModel):
    __tablename__ = 'transcode_session'
    client_device_user_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("client_device_user.id"),nullable=False
    )
    video_file_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("video_file.id"),nullable=True
    )
    streamable_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("streamable.id"),nullable=True
    )
    process_id = sa.Column(sa.Integer)
    stream_port = sa.Column(sa.Integer)
    transcode_directory = sa.Column(sa.Text)
    transcode_file = sa.Column(sa.Text)

class CachedText(BaseModel):
    __tablename__ = "cached_text"
    key = sa.Column(sa.Text)
    data = sa.Column(sa.Text)
    time_to_live_seconds = sa.Column(sa.Integer)

class Job(BaseModel):
    __tablename__ = "job"
    kind = sa.Column(sa.Text)
    message = sa.Column(sa.Text)
    status = sa.Column(sa.Text)
    logs_json = sa.Column(sa.Text)
    input_json = sa.Column(sa.Text)

class Tag(BaseModel):
    __tablename__ = "tag"
    name = sa.Column(sa.Text)
    movies: orm.Mapped[List["Movie"]] = orm.relationship(secondary="movie_tag",back_populates="tags")
    shows: orm.Mapped[List["Show"]] = orm.relationship(secondary="show_tag",back_populates="tags")
    show_seasons: orm.Mapped[List["ShowSeason"]] = orm.relationship(secondary="show_season_tag",back_populates="tags")
    show_episodes: orm.Mapped[List["ShowEpisode"]] = orm.relationship(secondary="show_episode_tag",back_populates="tags")
    stream_sources: orm.Mapped[List["StreamSource"]] = orm.relationship(secondary="stream_source_tag",back_populates="tags")
    streamables: orm.Mapped[List["Streamable"]] = orm.relationship(secondary="streamable_tag",back_populates="tags")

class ImageFile(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'image_file'
    __tablename__ = "image_file"
    shelf_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("shelf.id"))
    kind = sa.Column(sa.Text)
    local_path = sa.Column(sa.Text)
    web_path = sa.Column(sa.Text)
    network_path = sa.Column(sa.Text)
    thumbnail_web_path = sa.Column(sa.Text)
    movie: orm.Mapped["Movie"] = orm.relationship(secondary="movie_image_file", back_populates="image_files")
    movie_image_file: orm.Mapped["MovieImageFile"] = orm.relationship(back_populates="image_file",overlaps="movie")
    show_episode: orm.Mapped["ShowEpisode"] = orm.relationship(secondary="show_episode_image_file", back_populates="image_files")
    show_episode_image_file: orm.Mapped["ShowEpisodeImageFile"] = orm.relationship(back_populates="image_file",overlaps="show_episode")
    show_season: orm.Mapped["ShowSeason"] = orm.relationship(secondary="show_season_image_file", back_populates="image_files")
    show_season_image_file: orm.Mapped["ShowSeasonImageFile"] = orm.relationship(back_populates="image_file",overlaps="show_season")
    show: orm.Mapped["Show"] = orm.relationship(secondary="show_image_file", back_populates="image_files")
    show_image_file: orm.Mapped["ShowImageFile"] = orm.relationship(back_populates="image_file",overlaps="show")
    keepsake: orm.Mapped["Keepsake"] = orm.relationship(secondary="keepsake_image_file", back_populates="image_files")
    keepsake_image_file: orm.Mapped["KeepsakeImageFile"] = orm.relationship(back_populates="image_file",overlaps="keepsake")

class MetadataFile(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'metadata_file'
    __tablename__ = "metadata_file"
    shelf_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("shelf.id"))
    kind = sa.Column(sa.Text)
    local_path = sa.Column(sa.Text)
    web_path = sa.Column(sa.Text)
    network_path = sa.Column(sa.Text)
    xml_content = sa.Column(sa.Text)
    movie: orm.Mapped["Movie"] = orm.relationship(secondary="movie_metadata_file", back_populates="metadata_files")
    movie_metadata_file: orm.Mapped["MovieMetadataFile"] = orm.relationship(back_populates="metadata_file",overlaps="movie")
    show_episode: orm.Mapped["ShowEpisode"] = orm.relationship(secondary="show_episode_metadata_file", back_populates="metadata_files")
    show_episode_metadata_file: orm.Mapped["ShowEpisodeMetadataFile"] = orm.relationship(back_populates="metadata_file",overlaps="show_episode")
    show_season: orm.Mapped["ShowSeason"] = orm.relationship(secondary="show_season_metadata_file", back_populates="metadata_files")
    show_season_metadata_file: orm.Mapped["ShowSeasonMetadataFile"] = orm.relationship(back_populates="metadata_file",overlaps="show_season")
    show: orm.Mapped["Show"] = orm.relationship(secondary="show_metadata_file", back_populates="metadata_files")
    show_metadata_file: orm.Mapped["ShowMetadataFile"] = orm.relationship(back_populates="metadata_file",overlaps="show")


class VideoFile(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'video_file'
    __tablename__ = "video_file"
    shelf_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("shelf.id"))
    kind = sa.Column(sa.Text)
    local_path = sa.Column(sa.Text)
    web_path = sa.Column(sa.Text)
    network_path = sa.Column(sa.Text)
    snowstream_info_json = sa.Column(sa.Text)
    ffprobe_raw_json = sa.Column(sa.Text)
    mediainfo_raw_json = sa.Column(sa.Text)
    version = sa.Column(sa.Text)
    name = sa.Column(sa.Text)
    movie: orm.Mapped["Movie"] = orm.relationship(secondary="movie_video_file", back_populates="video_files")
    movie_video_file: orm.Mapped["MovieVideoFile"] = orm.relationship(back_populates="video_file",overlaps="movie")
    show_episode: orm.Mapped["ShowEpisode"] = orm.relationship(secondary="show_episode_video_file", back_populates="video_files")
    show_episode_video_file: orm.Mapped["ShowEpisodeVideoFile"] = orm.relationship(back_populates="video_file",overlaps="show_episode")
    keepsake: orm.Mapped["Keepsake"] = orm.relationship(secondary="keepsake_video_file", back_populates="video_files")
    keepsake_video_file: orm.Mapped["KeepsakeVideoFile"] = orm.relationship(back_populates="video_file",overlaps="keepsake")
    thumbnail_web_path = sa.Column(sa.Text)

class Shelf(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'shelf'
    __tablename__ = "shelf"
    name = sa.Column(sa.Text)
    kind = sa.Column(sa.Text)
    local_path = sa.Column(sa.Text)
    network_path = sa.Column(sa.Text)
    movies: orm.Mapped[List["Movie"]] = orm.relationship(secondary="movie_shelf",back_populates="shelf")
    shows: orm.Mapped[List["Show"]] = orm.relationship(secondary="show_shelf",back_populates="shelf")
    keepsakes: orm.Mapped[List["Keepsake"]] = orm.relationship(secondary="keepsake_shelf",back_populates="shelf")


class Movie(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'movie'
    __tablename__ = "movie"
    name = sa.Column(sa.Text)
    release_year = sa.Column(sa.Integer)
    directory = sa.Column(sa.Text)
    remote_metadata_id = sa.Column(sa.Integer)
    remote_metadata_source = sa.Column(sa.Text)
    in_progress: orm.Mapped["WatchProgress"] = orm.relationship(overlaps="movie", back_populates="movie")
    tags: orm.Mapped[List["Tag"]] = orm.relationship(secondary="movie_tag",back_populates="movies")
    video_files: orm.Mapped[List["VideoFile"]] = orm.relationship(secondary="movie_video_file",back_populates="movie",overlaps="movie_video_file")
    image_files: orm.Mapped[List["ImageFile"]] = orm.relationship(secondary="movie_image_file",back_populates="movie",overlaps="movie_image_file")
    metadata_files: orm.Mapped[List["MetadataFile"]] = orm.relationship(secondary="movie_metadata_file",back_populates="movie",overlaps="movie_metadata_file")
    shelf: orm.Mapped["Shelf"] = orm.relationship(secondary="movie_shelf")
    watch_count: orm.Mapped['WatchCount'] = orm.relationship(overlaps="movie")

    def get_tag_ids(self):
        if not self.tags:
            return []
        return [xx.id for xx in self.tags]

class MovieShelf(BaseModel):
    __tablename__ = "movie_shelf"
    movie_id = sa.Column(sa.Integer, sa.ForeignKey("movie.id"))
    shelf_id = sa.Column(sa.Integer, sa.ForeignKey("shelf.id"))


class MovieTag(BaseModel):
    __tablename__ = "movie_tag"
    movie_id = sa.Column(sa.Integer, sa.ForeignKey("movie.id"))
    tag_id = sa.Column(sa.Integer, sa.ForeignKey("tag.id"))


class MovieImageFile(BaseModel):
    __tablename__ = "movie_image_file"
    movie_id = sa.Column(sa.Integer, sa.ForeignKey("movie.id"))
    image_file_id = sa.Column(sa.Integer, sa.ForeignKey("image_file.id"))
    image_file: orm.Mapped['ImageFile'] = orm.relationship(back_populates='movie_image_file',overlaps="movie,image_files")


class MovieMetadataFile(BaseModel):
    __tablename__ = "movie_metadata_file"
    movie_id = sa.Column(sa.Integer, sa.ForeignKey("movie.id"))
    metadata_file_id = sa.Column(sa.Integer, sa.ForeignKey("metadata_file.id"))
    metadata_file: orm.Mapped['MetadataFile'] = orm.relationship(back_populates='movie_metadata_file',overlaps="movie,metadata_files")


class MovieVideoFile(BaseModel):
    __tablename__ = "movie_video_file"
    movie_id = sa.Column(sa.Integer, sa.ForeignKey("movie.id"))
    video_file_id = sa.Column(sa.Integer, sa.ForeignKey("video_file.id"))
    video_file: orm.Mapped['VideoFile'] = orm.relationship(back_populates="movie_video_file",overlaps="movie,video_files")

class PlayingQueue(BaseModel):
    __tablename__ = "playing_queue"
    client_device_user_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("client_device_user.id"),
        nullable=False
    )
    client_device_user: orm.Mapped["ClientDeviceUser"] = orm.relationship()
    source = sa.Column(sa.Text)
    content = sa.Column(sa.Text)
    progress = sa.Column(sa.Integer)
    length = sa.Column(sa.Integer)

class Show(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'show'
    __tablename__ = "show"
    name = sa.Column(sa.Text)
    directory = sa.Column(sa.Text)
    release_year = sa.Column(sa.Integer)
    remote_metadata_id = sa.Column(sa.Integer)
    remote_metadata_source = sa.Column(sa.Text)
    shelf: orm.Mapped["Shelf"] = orm.relationship(secondary="show_shelf",back_populates="shows")
    seasons: orm.Mapped[List["ShowSeason"]] = orm.relationship(back_populates='show',order_by="ShowSeason.season_order_counter")
    image_files: orm.Mapped[List["ImageFile"]] = orm.relationship(secondary="show_image_file",back_populates="show",overlaps="show_image_file")
    metadata_files: orm.Mapped[List["MetadataFile"]] = orm.relationship(secondary="show_metadata_file",back_populates="show",overlaps="show_metadata_file")
    tags: orm.Mapped[List['Tag']] = orm.relationship(secondary="show_tag",back_populates="shows")

    def get_tag_ids(self):
        if not self.tags:
            return []
        return [xx.id for xx in self.tags]

class ShowShelf(BaseModel):
    __tablename__ = "show_shelf"
    show_id = sa.Column(sa.Integer, sa.ForeignKey("show.id"))
    shelf_id = sa.Column(sa.Integer, sa.ForeignKey("shelf.id"))

class ShowTag(BaseModel):
    __tablename__ = "show_tag"
    show_id = sa.Column(sa.Integer, sa.ForeignKey("show.id"))
    tag_id = sa.Column(sa.Integer, sa.ForeignKey("tag.id"))

class ShowImageFile(BaseModel):
    __tablename__ = "show_image_file"
    show_id = sa.Column(sa.Integer, sa.ForeignKey("show.id"))
    image_file_id = sa.Column(sa.Integer, sa.ForeignKey("image_file.id"))
    image_file: orm.Mapped['ImageFile'] = orm.relationship(back_populates='show_image_file',overlaps="show,image_files")


class ShowMetadataFile(BaseModel):
    __tablename__ = "show_metadata_file"
    show_id = sa.Column(sa.Integer, sa.ForeignKey("show.id"))
    metadata_file_id = sa.Column(sa.Integer, sa.ForeignKey("metadata_file.id"))
    metadata_file: orm.Mapped['MetadataFile'] = orm.relationship(back_populates='show_metadata_file',overlaps="show,metadata_files")

class ShowSeason(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'show_season'
    __tablename__ = "show_season"
    name = sa.Column(sa.Text)
    directory = sa.Column(sa.Text)
    season_order_counter = sa.Column(sa.Integer)
    show_id: orm.Mapped[int] = sa.Column(sa.Integer, sa.ForeignKey("show.id"))
    show: orm.Mapped["Show"] = orm.relationship(back_populates="seasons")
    episodes: orm.Mapped[List["ShowEpisode"]] = orm.relationship(back_populates="season",order_by="ShowEpisode.episode_order_counter")
    image_files: orm.Mapped[List["ImageFile"]] = orm.relationship(secondary="show_season_image_file",back_populates="show_season",overlaps="show_season_image_file")
    metadata_files: orm.Mapped[List["MetadataFile"]] = orm.relationship(secondary="show_season_metadata_file",back_populates="show_season",overlaps="show_season_metadata_file")
    tags: orm.Mapped[List["Tag"]] = orm.relationship(secondary="show_season_tag",back_populates="show_seasons")

    def get_tag_ids(self):
        tag_ids = []
        if self.show:
            tag_ids += self.show.get_tag_ids()
        return [xx.id for xx in self.tags] + tag_ids

class ShowSeasonTag(BaseModel):
    __tablename__ = "show_season_tag"
    show_season_id = sa.Column(sa.Integer, sa.ForeignKey("show_season.id"))
    tag_id = sa.Column(sa.Integer, sa.ForeignKey("tag.id"))

class ShowSeasonImageFile(BaseModel):
    __tablename__ = "show_season_image_file"
    show_season_id = sa.Column(sa.Integer, sa.ForeignKey("show_season.id"))
    image_file_id = sa.Column(sa.Integer, sa.ForeignKey("image_file.id"))
    image_file: orm.Mapped['ImageFile'] = orm.relationship(back_populates='show_season_image_file',overlaps="show_season,image_files")


class ShowSeasonMetadataFile(BaseModel):
    __tablename__ = "show_season_metadata_file"
    show_season_id = sa.Column(sa.Integer, sa.ForeignKey("show_season.id"))
    metadata_file_id = sa.Column(sa.Integer, sa.ForeignKey("metadata_file.id"))
    metadata_file: orm.Mapped['MetadataFile'] = orm.relationship(back_populates='show_season_metadata_file',overlaps="show_season,metadata_files")

class ShowEpisode(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'show_episode'
        self.episode_slug = ''

    __tablename__ = "show_episode"
    name = sa.Column(sa.Text)
    episode_order_counter = sa.Column(sa.Integer)
    episode_end_order_counter = sa.Column(sa.Integer)
    show_season_id: orm.Mapped[int] = orm.mapped_column(sa.ForeignKey("show_season.id"))
    in_progress: orm.Mapped["WatchProgress"] = orm.relationship(overlaps="show_episode", back_populates="show_episode")
    video_files: orm.Mapped[List["VideoFile"]] = orm.relationship(secondary="show_episode_video_file",back_populates="show_episode",overlaps="show_episode_video_file")
    image_files: orm.Mapped[List["ImageFile"]] = orm.relationship(secondary="show_episode_image_file",back_populates="show_episode",overlaps="show_episode_image_file")
    metadata_files: orm.Mapped[List["MetadataFile"]] = orm.relationship(secondary="show_episode_metadata_file",back_populates="show_episode",overlaps="show_episode_metadata_file")
    season: orm.Mapped["ShowSeason"] = orm.relationship(back_populates="episodes")
    tags: orm.Mapped[List["Tag"]] = orm.relationship(secondary="show_episode_tag",back_populates="show_episodes")
    watch_count: orm.Mapped['WatchCount'] = orm.relationship(overlaps="show_episode")

    def get_tag_ids(self):
        tag_ids = []
        if self.season.show and self.season.show.tags:
            tag_ids += self.season.show.get_tag_ids()
        if self.season and self.season.tags:
            tag_ids += self.season.get_tag_ids()
        if not self.tags:
            return tag_ids
        return [xx.id for xx in self.tags] + tag_ids

class ShowEpisodeTag(BaseModel):
    __tablename__ = "show_episode_tag"
    show_episode_id = sa.Column(sa.Integer, sa.ForeignKey("show_episode.id"))
    tag_id = sa.Column(sa.Integer, sa.ForeignKey("tag.id"))

class ShowEpisodeImageFile(BaseModel):
    __tablename__ = "show_episode_image_file"
    show_episode_id = sa.Column(sa.Integer, sa.ForeignKey("show_episode.id"))
    image_file_id = sa.Column(sa.Integer, sa.ForeignKey("image_file.id"))
    image_file: orm.Mapped['ImageFile'] = orm.relationship(back_populates='show_episode_image_file',overlaps="image_files,show_episode")


class ShowEpisodeMetadataFile(BaseModel):
    __tablename__ = "show_episode_metadata_file"
    show_episode_id = sa.Column(sa.Integer, sa.ForeignKey("show_episode.id"))
    metadata_file_id = sa.Column(sa.Integer, sa.ForeignKey("metadata_file.id"))
    metadata_file: orm.Mapped['MetadataFile'] = orm.relationship(back_populates='show_episode_metadata_file',overlaps="metadata_files,show_episode")


class ShowEpisodeVideoFile(BaseModel):
    __tablename__ = "show_episode_video_file"
    show_episode_id = sa.Column(sa.Integer, sa.ForeignKey("show_episode.id"))
    video_file_id = sa.Column(sa.Integer, sa.ForeignKey("video_file.id"))
    video_file: orm.Mapped['VideoFile'] = orm.relationship(back_populates="show_episode_video_file",overlaps="video_files,show_episode")


class StreamSource(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'stream_source'
    __tablename__ = "stream_source"
    kind = sa.Column(sa.Text)
    name = sa.Column(sa.Text, unique=True)
    url = sa.Column(sa.Text, unique=True)
    username = sa.Column(sa.Text)
    password = sa.Column(sa.Text)
    streamables: orm.Mapped[List["Streamable"]] = orm.relationship()
    tags: orm.Mapped[List["Tag"]] = orm.relationship(secondary="stream_source_tag",back_populates="stream_sources")

    def get_tag_ids(self):
        if not self.tags:
            return []
        return [xx.id for xx in self.tags]

class StreamSourceTag(BaseModel):
    __tablename__ = 'stream_source_tag'
    stream_source_id = sa.Column(sa.Integer, sa.ForeignKey("stream_source.id"))
    tag_id = sa.Column(sa.Integer, sa.ForeignKey("tag.id"))

class Streamable(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'streamable'
    __tablename__ = "streamable"
    url = sa.Column(sa.Text)
    name = sa.Column(sa.Text)
    name_display = sa.Column(sa.Text)
    group = sa.Column(sa.Text)
    group_display = sa.Column(sa.Text)
    stream_source_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("stream_source.id")
    )
    stream_source: orm.Mapped["StreamSource"] = orm.relationship(back_populates="streamables")
    channel: orm.Mapped["Channel"] = orm.relationship(secondary="streamable_channel",back_populates="streamable",overlaps="streamable_channel")
    tags: orm.Mapped[List["Tag"]] = orm.relationship(secondary="streamable_tag",back_populates="streamables")

    def _ids(self):
        return [xx.id for xx in self.tags]

class StreamableTag(BaseModel):
    __tablename__ = 'streamable_tag'
    streamable_id = sa.Column(sa.Integer, sa.ForeignKey("streamable.id"))
    tag_id = sa.Column(sa.Integer, sa.ForeignKey("tag.id"))

class ChannelGuideSource(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'channel_guide_source'
    __tablename__ = "channel_guide_source"
    kind = sa.Column(sa.Text)
    name = sa.Column(sa.Text, unique=True)
    url = sa.Column(sa.Text, unique=True)
    username = sa.Column(sa.Text)
    password = sa.Column(sa.Text)
    channels: orm.Mapped[List["Channel"]] = orm.relationship(back_populates="channel_guide_source")

class Channel(BaseModel):
    def init_on_load(self):
        self.model_kind = 'channel'
    __tablename__ = "channel"
    channel_guide_source_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("channel_guide_source.id")
    )
    channel_guide_source: orm.Mapped["ChannelGuideSource"] = orm.relationship(back_populates="channels")
    parsed_id = sa.Column(sa.Text)
    parsed_name = sa.Column(sa.Text)
    parsed_number = sa.Column(sa.Float)
    edited_id = sa.Column(sa.Text)
    edited_name = sa.Column(sa.Text)
    edited_number = sa.Column(sa.Float)
    programs: orm.Mapped[List["ChannelProgram"]] = orm.relationship(back_populates="channel")
    streamable: orm.Mapped["Streamable"] = orm.relationship(secondary="streamable_channel",back_populates="channel",overlaps="streamable_channel")

class ChannelProgram(BaseModel):
    def init_on_load(self):
        self.model_kind = 'channel_program'
    __tablename__ = "channel_program"
    channel_id: orm.Mapped[int] = orm.mapped_column(
        sa.ForeignKey("channel.id")
    )
    channel: orm.Mapped["Channel"] = orm.relationship(back_populates="programs")
    name = sa.Column(sa.Text)
    description = sa.Column(sa.Text)
    start_datetime = sa.Column(sa.DateTime)
    stop_datetime = sa.Column(sa.DateTime)

class StreamableChannel(BaseModel):
    __tablename__ = 'streamable_channel'
    streamable_id = sa.Column(sa.Integer, sa.ForeignKey("streamable.id"))
    channel_id = sa.Column(sa.Integer, sa.ForeignKey("channel.id"))

class Keepsake(BaseModel):
    @orm.reconstructor
    def init_on_load(self):
        self.model_kind = 'keepsake'
    __tablename__ = "keepsake"
    directory = sa.Column(sa.Text)
    video_files: orm.Mapped[List["VideoFile"]] = orm.relationship(secondary="keepsake_video_file",back_populates="keepsake",overlaps="keepsake_video_file")
    image_files: orm.Mapped[List["ImageFile"]] = orm.relationship(secondary="keepsake_image_file",back_populates="keepsake",overlaps="keepsake_image_file")
    shelf: orm.Mapped["Shelf"] = orm.relationship(secondary="keepsake_shelf")

class KeepsakeShelf(BaseModel):
    __tablename__ = "keepsake_shelf"
    keepsake_id = sa.Column(sa.Integer, sa.ForeignKey("keepsake.id"))
    shelf_id = sa.Column(sa.Integer, sa.ForeignKey("shelf.id"))

class KeepsakeVideoFile(BaseModel):
    __tablename__ = "keepsake_video_file"
    keepsake_id = sa.Column(sa.Integer, sa.ForeignKey("keepsake.id"))
    video_file_id = sa.Column(sa.Integer, sa.ForeignKey("video_file.id"))
    video_file: orm.Mapped['VideoFile'] = orm.relationship(back_populates="keepsake_video_file",overlaps="keepsake,video_files")

class KeepsakeImageFile(BaseModel):
    __tablename__ = "keepsake_image_file"
    keepsake_id = sa.Column(sa.Integer, sa.ForeignKey("keepsake.id"))
    image_file_id = sa.Column(sa.Integer, sa.ForeignKey("image_file.id"))
    image_file: orm.Mapped['ImageFile'] = orm.relationship(back_populates='keepsake_image_file',overlaps="keepsake,image_files")

class DisplayCleanupRule(BaseModel):
    __tablename__ = 'display_cleanup_rule'
    target_kind = sa.Column(sa.Text)
    rule_kind = sa.Column(sa.Text)
    priority = sa.Column(sa.Integer)
    needle = sa.Column(sa.Text)
    replacement = sa.Column(sa.Text)

# For whatever reason, aliased cannot be called until after ALL models are defined
# Otherwise you get a bunch of "model cannot map X to Y" errors
ShowTagAlias = orm.aliased(Tag)
ShowSeasonTagAlias = orm.aliased(Tag)
ShowEpisodeTagAlias = orm.aliased(Tag)